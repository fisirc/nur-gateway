const std = @import("std");
const builtin = @import("builtin");

pub const c = @import("pq/binds.zig");

pub const ExecError = error {
    IsNull,
    QueryError,
    QueryOutOfMemory,
    EmptyStringParam,
};

pub const ConnError = error{
    BadConnection,
};

pub const ConnStatus = enum {
    /// a good connection to the database was established
    connection_ok,

    /// connection attempt failed
    connection_bad,

    /// there are a number of possible statuses, some may not be translated still
    unknown,
};

pub const ExecStatus = enum {
    /// the string sent to the server was empty.
    empty_query,

    /// successful completion of a command returning no data.
    command_ok,

    /// successful completion of a command returning data (such as a select or show).
    tuples_ok,

    /// copy out (from server) data transfer started.
    copy_out,

    /// copy in (to server) data transfer started.
    copy_in,

    /// the server's response was not understood.
    bad_response,

    /// a nonfatal error (a notice or warning) occurred.
    nonfatal_error,

    /// a fatal error occurred.
    fatal_error,

    /// copy in/out (to and from server) data transfer started.
    copy_both,

    /// the pgresult contains a single result tuple from the current command.
    single_tuple,

    /// the pgresult contains several result tuples from the current command.
    tuples_chunk,

    /// the pgresult represents a synchronization point in pipeline mode.
    pipeline_sync,

    /// the pgresult represents a pipeline that has received an error from the server.
    pipeline_aborted,
};

const QueryResult = struct {
    const Self = @This();

    /// you are not supposed to use this field directly outside ffi necessities
    _c_result: *c.PGresult,

    /// clears the storage of a `result` including result values
    pub fn clear(self: Self) void {
        c.PQclear(self._c_result);
    }

    /// returns the result status code to check for errors
    pub fn status(self: Self) ExecStatus {
        return switch(c.PQresultStatus(self._c_result)) {
            c.PGRES_EMPTY_QUERY => ExecStatus.empty_query,
            c.PGRES_COMMAND_OK => ExecStatus.command_ok,
            c.PGRES_TUPLES_OK  => ExecStatus.tuples_ok,
            c.PGRES_COPY_OUT  => ExecStatus.copy_out,
            c.PGRES_COPY_IN  => ExecStatus.copy_in,
            c.PGRES_BAD_RESPONSE  => ExecStatus.bad_response,
            c.PGRES_NONFATAL_ERROR  => ExecStatus.nonfatal_error,
            c.PGRES_FATAL_ERROR  => ExecStatus.fatal_error,
            c.PGRES_COPY_BOTH  => ExecStatus.copy_both,
            c.PGRES_SINGLE_TUPLE  => ExecStatus.single_tuple,
            c.PGRES_TUPLES_CHUNK  => ExecStatus.tuples_chunk,
            c.PGRES_PIPELINE_SYNC  => ExecStatus.pipeline_sync,
            c.PGRES_PIPELINE_ABORTED  => ExecStatus.pipeline_aborted,

            else => @panic("illegal exec status code"),
        };
    }

    /// returns the number of rows returned into some query result
    pub fn rowsLen(self: Self) usize {
        const n_tuples: c_int = c.PQntuples(self._c_result);
        return @intCast(n_tuples);
    }

    /// return the value located at column `col_idx` of the row `row_idx` (starting at 0) from the result (which owns the memory)
    pub fn getValueAt(self: Self, row_idx: usize, col_idx: usize) []const u8 {
        const value_textformat = c.PQgetvalue(self._c_result, @intCast(row_idx), @intCast(col_idx));
        const value_textlength = std.mem.len(value_textformat);
        return value_textformat[0..value_textlength];
    }
};

pub const Conn = struct {
    const Self = @This();

    /// you are not supposed to use this field directly outside ffi necessities
    _c_conn: *c.PGconn,

    /// establishes a connection to the db and returns a connection pointer
    pub fn fromUriZ(uri: [:0]const u8) ConnError!Self {
        const new_connection = Self{
            ._c_conn = c.PQconnectdb(uri.ptr) orelse return ConnError.BadConnection,
        };

        const connection_status = new_connection.status();
        if (connection_status != .connection_ok) {
            if (builtin.mode == .Debug) {
                std.debug.print("connection error message: {s}", .{
                    // there should always be an error message at this point
                    new_connection.getErrorMessage().?,
                });
            }

            return ConnError.BadConnection;
        }

        return new_connection;
    }

    /// finish the connection and free the related resources
    pub fn finish(self: Self) void {
        c.PQfinish(self._c_conn);
    }

    pub fn status(self: Self) ConnStatus {
        return switch (c.PQstatus(self._c_conn)) {
            c.CONNECTION_OK => .connection_ok,
            c.CONNECTION_BAD => .connection_bad,
            else => .unknown,
        };
    }

    /// returns the error message most recently generated by an operation on the
    /// connection, null if none. The connection underlyingly "owns" the memory, it
    /// gets freed with it at finish
    pub fn getErrorMessage(self: Self) ?[]const u8 {
        const error_message = c.PQerrorMessage(self._c_conn);
        const error_len = std.mem.len(error_message);
        return error_message[0..error_len];
    }

    pub fn execQueryZ(self: Self, query: [:0]u8) ExecError!*QueryResult {
        const query_result: *QueryResult = c.PQexec(self._c_conn, query) orelse ExecError.IsNull;
        if (c.PQresultStatus(query_result) != c.PGRES_TUPLES_OK) {
            return ExecError.QueryError;
        }

        return query_result;
    }

    pub fn execQueryZWithParams(self: Self, query: [*:0]const u8, params: anytype) ExecError!QueryResult {
        const params_typeinfo = @typeInfo(@TypeOf(params)).@"struct";
        const params_fields_typeinfo = params_typeinfo.fields;
        const n_params = params_fields_typeinfo.len;

        // inferred
        const param_types: ?[*]c.Oid = null;

        // we will use the text format for all param values to avoid binary enc/dec
        // problems
        var params_text_values: [n_params][*]const u8 = undefined;

        // text = 0, binary = 1
        const text_format = 0;
        const param_formats: [n_params]c_int = @splat(text_format);

        // i would rather use a usize here (they are sizes after all) but the api
        // uses `int`s
        const params_typesizes: ?[*]c_int = null;

        // the arena will own the memory of the params text-values
        var new_arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
        defer new_arena.deinit();

        const allocator = new_arena.allocator();

        inline for (0..n_params) |idx| {
            const param = params[idx];
            const param_type = @TypeOf(param);

            const fmt = switch (param_type) {
                []u8, []const u8, [:0]u8, [:0]const u8 => str_fmt: {
                    if (param.len == 0) return ExecError.EmptyStringParam;

                    break :str_fmt "{s}";
                },
                else => "{}",
            };

            params_text_values[idx] = (std.fmt.allocPrintZ(allocator, fmt, .{
                param,
                }) catch return ExecError.QueryOutOfMemory).ptr;
        }

        const query_result_ffi = c.PQexecParams(
            self._c_conn,
            query,
            n_params,
            param_types,
            &params_text_values,
            params_typesizes,
            &param_formats,
            text_format,
        ) orelse return ExecError.IsNull;

        const query_result = QueryResult{
            ._c_result = query_result_ffi,
        };

        if (query_result.status() != ExecStatus.tuples_ok) {
            return ExecError.QueryError;
        }

        return query_result;
    }
};
