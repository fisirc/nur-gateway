const std = @import("std");

pub const bindings = @import("pq/binds.zig");
const PGConn = bindings.PGconn;

pub const ConnError = error.BadConnection;

pub fn connectDbSafe(uri: [:0]const u8) !*PGConn {
    const new_connection = bindings.PQconnectdb(uri.ptr) orelse return ConnError;
    const connection_status = bindings.PQstatus(new_connection);
    if (connection_status != bindings.CONNECTION_OK) {
        return ConnError;
    }

    return new_connection;
}

/// finish the connection and free the related resources
pub fn finishConn(conn: *PGConn) void {
    bindings.PQfinish(conn);
}

pub const ExecError = error {
    IsNull,
    QueryError,
    QueryOutOfMemory,
};

const QueryResult = bindings.PGresult;

pub fn execQuery(conn: *PGConn, query: [:0]u8) ExecError!*QueryResult {
    const query_result: *QueryResult = bindings.PQexec(conn, query) orelse ExecError.IsNull;
    if (bindings.PQresultStatus(query_result) != bindings.PGRES_TUPLES_OK) {
        return ExecError.QueryError;
    }

    return query_result;
}

pub fn execQueryWithParams(conn: *PGConn, query: [*:0]const u8, params: anytype) ExecError!*QueryResult {
    const params_typeinfo = @typeInfo(@TypeOf(params)).@"struct";
    const params_fields_typeinfo = params_typeinfo.fields;
    const n_params = params_fields_typeinfo.len;

    // inferred
    const param_types: ?[*]bindings.Oid = null;
    
    // for the param values, we will use text for all to avoid binary enc/dec
    // problems
    var params_text_values: [n_params][*]const u8 = undefined;

    // text = 0, binary = 1
    const text_format = 0;
    const param_formats: [n_params]c_int = @splat(text_format);

    // i would rather use a usize here (they are sizes after all) but the api
    // uses `int`s
    var params_typesizes: [n_params]c_int = @splat(0);

    // the gpa will own the memory of the params text-values
    var new_arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer new_arena.deinit();
    
    const allocator = new_arena.allocator();

    inline for (0..n_params) |idx| {
        params_text_values[idx] = (std.fmt.allocPrint(allocator, "{}", .{
            params[idx],
        }) catch return ExecError.QueryOutOfMemory).ptr;

        params_typesizes[idx] = @intCast(@sizeOf(params_fields_typeinfo[idx].type));
    }

    const query_result: *QueryResult = bindings.PQexecParams(
        conn,
        query,
        n_params,
        param_types,
        &params_text_values,
        &params_typesizes,
        &param_formats,
        text_format,
    ) orelse return ExecError.IsNull;

    if (bindings.PQresultStatus(query_result) != bindings.PGRES_TUPLES_OK) {
        return ExecError.QueryError;
    }

    return query_result;
}

/// Returns the error message most recently generated by an operation on the
/// connection, null if none. The connection underlyingly "owns" the memory, it
/// gets freed with it at PQFinish
pub fn getErrorMessage(conn: *PGConn) ?[]const u8 {
    const error_message = bindings.PQerrorMessage(conn);
    const error_len = std.mem.len(error_message);
    return error_message[0..error_len];
}



