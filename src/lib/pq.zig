const std = @import("std");

pub const bindings = @import("pq/binds.zig");
const PGConn = bindings.PGconn;

pub const ConnError = error.BadConnection;

pub fn connectDbSafe(uri: [:0]const u8) !*PGConn {
    const new_connection = bindings.PQconnectdb(uri.ptr) orelse return ConnError;
    const connection_status = bindings.PQstatus(new_connection);
    if (connection_status != bindings.CONNECTION_OK) {
        return ConnError;
    }

    return new_connection;
}

/// finish the connection and free the related resources
pub fn finishConn(conn: *PGConn) void {
    bindings.PQfinish(conn);
}

pub const ExecError = error {
    IsNull,
    QueryError,
    QueryOutOfMemory,
    EmptyStringParam,
};

const QueryResult = bindings.PGresult;

/// returns the number of rows returned into some query result
pub fn resultRowsLen(result: *QueryResult) usize {
    const n_tuples: c_int = bindings.PQntuples(result);
    return @intCast(n_tuples);
}

/// return the value located at column `col_idx` of the row `row_idx` (starting at 0) from the result (which owns the memory)
pub fn getValueAt(result: *QueryResult, row_idx: usize, col_idx: usize) []const u8 {
    const value_textformat = bindings.PQgetvalue(result, @intCast(row_idx), @intCast(col_idx));
    const value_textlength = std.mem.len(value_textformat);
    return value_textformat[0..value_textlength];
}

pub fn execQuery(conn: *PGConn, query: [:0]u8) ExecError!*QueryResult {
    const query_result: *QueryResult = bindings.PQexec(conn, query) orelse ExecError.IsNull;
    if (bindings.PQresultStatus(query_result) != bindings.PGRES_TUPLES_OK) {
        return ExecError.QueryError;
    }

    return query_result;
}

pub fn execQueryWithParams(conn: *PGConn, query: [*:0]const u8, params: anytype) ExecError!*QueryResult {
    const params_typeinfo = @typeInfo(@TypeOf(params)).@"struct";
    const params_fields_typeinfo = params_typeinfo.fields;
    const n_params = params_fields_typeinfo.len;

    // inferred
    const param_types: ?[*]bindings.Oid = null;
    
    // for the param values, we will use text for all to avoid binary enc/dec
    // problems
    var params_text_values: [n_params][*]const u8 = undefined;

    // text = 0, binary = 1
    const text_format = 0;
    const param_formats: [n_params]c_int = @splat(text_format);

    // i would rather use a usize here (they are sizes after all) but the api
    // uses `int`s
    const params_typesizes: ?[*]c_int = null;

    // the gpa will own the memory of the params text-values
    var new_arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer new_arena.deinit();
    
    const allocator = new_arena.allocator();

    inline for (0..n_params) |idx| {
        const param = params[idx];
        const param_type = @TypeOf(param);
        
        const fmt = switch (param_type) {
            []u8, []const u8, [:0]u8, [:0]const u8 => str_fmt: {
                if (param.len == 0) return ExecError.EmptyStringParam;

                break :str_fmt "{s}";
            },
            else => "{}",
        };

        params_text_values[idx] = (std.fmt.allocPrintZ(allocator, fmt, .{
            param,
        }) catch return ExecError.QueryOutOfMemory).ptr;
    }

    const query_result: *QueryResult = bindings.PQexecParams(
        conn,
        query,
        n_params,
        param_types,
        &params_text_values,
        params_typesizes,
        &param_formats,
        text_format,
    ) orelse return ExecError.IsNull;

    if (bindings.PQresultStatus(query_result) != bindings.PGRES_TUPLES_OK) {
        return ExecError.QueryError;
    }

    return query_result;
}

/// Returns the error message most recently generated by an operation on the
/// connection, null if none. The connection underlyingly "owns" the memory, it
/// gets freed with it at PQFinish
pub fn getErrorMessage(conn: *PGConn) ?[]const u8 {
    const error_message = bindings.PQerrorMessage(conn);
    const error_len = std.mem.len(error_message);
    return error_message[0..error_len];
}



